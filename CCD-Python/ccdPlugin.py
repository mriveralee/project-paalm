#-
# ==========================================================================
# Copyright (C) 1995 - 2006 Autodesk, Inc. and/or its licensors.  All 
# rights reserved.
#
# The coded instructions, statements, computer programs, and/or related 
# material (collectively the "Data") in these files contain unpublished 
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its 
# licensors, which is protected by U.S. and Canadian federal copyright 
# law and by international treaties.
#
# The Data is provided for use exclusively by You. You have the right 
# to use, modify, and incorporate this Data into other products for 
# purposes authorized by the Autodesk software license agreement, 
# without fee.
#
# The copyright notices in the Software and this entire statement, 
# including the above license grant, this restriction and the 
# following disclaimer, must be included in all copies of the 
# Software, in whole or in part, and all derivative works of 
# the Software, unless such copies or derivative works are solely 
# in the form of machine-executable object code generated by a 
# source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
# AUTODESK DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED 
# WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF 
# NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
# PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
# TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS LICENSORS 
# BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK 
# AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
# OR PROBABILITY OF SUCH DAMAGES.
#
# ==========================================================================
#+

# import maya.cmds as cmds
# cmds.createNode("transform", name="ccdNode1")
# cmds.createNode("mesh", name="ccdNodeShape1", parent="ccdNode1")
# cmds.sets("ccdNodeShape1", add="initialShadingGroup")
# cmds.createNode("spccdNode", name="ccdNodeNode1")
# cmds.connectAttr("time1.outTime", "ccdNodeNode1.time")
# cmds.connectAttr("ccdNodeNode1.outputMesh", "ccdNodeShape1.inMesh")



cmds.createNode("transform", name="joint4")
cmds.connectAttr("time1.outTime", "joint4.time")
# cmds.createNode("spccdNode", name="ccdNodeNode1")
# cmds.connectAttr("time1.outTime", "ccdNodeNode1.time")
# cmds.connectAttr("ccdNodeNode1.outputMesh", "ccdNodeShape1.inMesh")


''' GET POSITION OF JOINT ''' # =====> cmds.getAttr('joint4.translate')
#To get position of joint in WS-> pos = cmds.getAttr(<objectName>.translate)
#return value is an array of size 1 containing an array of float values
# x-coord = pos[0][0]
# y-coord = pos[0][1]
# z-coord = pos[0][1]

''' SET POSITION OF JOINT ''' # =====> cmds.setAttr('joint4.translate',)
# setAttr object.translateY 10.5;
# or:
# setAttr object.translate -1.5 10.5 0;


'''PYMEL Example for translating in ws and get getting the current
        import pymel.all as pm
    #Translate using location coordinates
        pm.setAttr('joint4.translate', -1.5, 10.5, 0)

    #Translate in WS coordinates
        pm.xform('joint4', ws=True,t=(0, 0,0))
        f = pm.getAttr('joint4.translate')
        print f
        print pm.select('joint4')

    #Get World coordinates of object
    coords = pm.xform('joint4', t=True, query=True, ws=True) //in an array [x,y,z

    #Get Rotation of object
    coords = pm.xform('joint5', query=True, rotation=True)

'''


#SAMPLE_POINT = [13.327005785798825, 5.933350084777719, 1.6255290651771213];


import pymel.all as pm
import sys
import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
import Leap, string, math

kPluginNodeName = "spCCDNode"
kPluginNodeId = OpenMaya.MTypeId(0x8700B)

class ccdNode(OpenMayaMPx.MPxNode):
    time = OpenMaya.MObject()
    outputMesh = OpenMaya.MObject()

    def __init__(self):
        OpenMayaMPx.MPxNode.__init__(self)

    def createMesh(self, tempTime, outData):
        frame = int(tempTime.asUnits(OpenMaya.MTime.kFilm))
        if frame is 0:
            frame = 1
        # vtx_1 = OpenMaya.MFloatPoint(-cubeSize, -cubeSize, -cubeSize)
        # vtx_2 = OpenMaya.MFloatPoint( cubeSize, -cubeSize, -cubeSize)

        # points = OpenMaya.MFloatPointArray()
        # points.setLength(8)
        # faceCounts = OpenMaya.MIntArray()
        # meshFS = OpenMaya.MFnMesh()
        # newMesh = meshFS.create(numVertices, numFaces, points, faceCounts, faceConnects, outData)
        return 0
        # return newMesh

    def compute(self, plug, data):
        if plug == ccdNode.outputMesh:
            timeData = data.inputValue(ccdNode.time)
            tempTime = timeData.asTime()

            #outputHandle = data.outputValue(ccdNode.outputMesh)

            #dataCreator = OpenMaya.MFnMeshData()
            #newOutputData = dataCreator.create()

            self.createMesh(tempTime, newOutputData)

           # outputHandle.setMObject(newOutputData)
            data.setClean(plug)
        else:
            return OpenMaya.kUnknownParameter

def nodeCreator():
    return OpenMayaMPx.asMPxPtr( ccdNode() )

def nodeInitializer():
    unitAttr = OpenMaya.MFnUnitAttribute()
    typedAttr = OpenMaya.MFnTypedAttribute()

    ccdNode.time = unitAttr.create("time", "tm", OpenMaya.MFnUnitAttribute.kTime, 0.0)
    #ccdNode.outputMesh = typedAttr.create("outputMesh", "out", OpenMaya.MFnData.kMesh)

    ccdNode.addAttribute(ccdNode.time)
    #ccdNode.addAttribute(ccdNode.outputMesh)

    ccdNode.attributeAffects(ccdNode.time, ccdNode.outputMesh)

    #initialize positions of points
    initializePositions()


# initialize the script plug-in
def initializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.registerNode( kPluginNodeName, kPluginNodeId, nodeCreator, nodeInitializer)
    except:
        sys.stderr.write( "Failed to register node: %s" % kPluginNodeName )
        raise

# uninitialize the script plug-in
def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterNode( kPluginNodeId )
    except:
        sys.stderr.write( "Failed to deregister node: %s" % kPluginNodeName )
        raise
        
###################

import pymel.all as pm
import sys
import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
import Leap, string, math

#Target point of interest - initial conditions
#TP = [13.327005785798825, 5.933350084777719, 1.6255290651771213];
#TARGET_POINT = Leap.Vector(TP[0],TP[1], TP[2])

#Joints and Positions of finger
JOINTS = {
   'joint1': {
        'base-pos': Leap.Vector(0, 0, 0),
        'pos': Leap.Vector(0, 0, 0),
        'rot': Leap.Vector(0, 90, 0),
        'name': 'palm'
    },
    'joint2': {
        'base-pos': Leap.Vector(0, 0, -5),
        'pos': Leap.Vector(0, 0, -5),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'knuckle'
    },
    'joint3': {
        'base-pos': Leap.Vector(0, 0, -10),
        'pos': Leap.Vector(0, 0, -10),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'mid-joint'
    },
    'joint4': {
        'base-pos': Leap.Vector(0, 0, -15),
        'pos': Leap.Vector(0, 0, -15),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'tip-joint'
    },
    'joint5': {
        'base-pos': Leap.Vector(0, 0, -20),
        'pos': Leap.Vector(0, 0, -20),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'end-effector'
    },
    'targetPoint': {
        'base-pos': Leap.Vector(0,0,0),
        'pos': Leap.Vector(0,0,0),
        'rot': Leap.Vector(0,0,0),
        'name': 'targetPoint'
    }
}


#Initialize our positions from out Maya joint        
def initializePositions():
    #Get the Current Target Position
    targetPosKey = 'targetPoint'
    posX = pm.xform(targetPosKey, query=True, t=True, ws=True)
    TARGET_POINT = Leap.Vector(posX[0], posX[1], posX[2])
    #Joint Positions
    for key in JOINTS:
        print key
        #Get position of joint
        pos = pm.xform(key, query=True, t=True, ws=True) #//in an array [x,y,z]
        JOINTS[key]['base-pos'] = Leap.Vector(pos[0], pos[1], pos[2])
        JOINTS[key]['pos'] = Leap.Vector(pos[0], pos[1], pos[2])

        #Get Rotatation of joint
        rot = pm.xform(key, query=True, rotation=True)   
        JOINTS[key]['rot'] = Leap.Vector(rot[0], rot[1], rot[2])


#CCD algorithm - with a targetPos
def perform_ccd():  #formerly perform_ccd(self,targetTipPos)
    initializePositions()
    targetTipPos = JOINTS['targetPoint']['pos']
    #print "ccd test"
    # While distance from effector to target > threshold and numloops<max
            #   Take current bone
            #   Build vector V1 from bone pivot to effector
            #   Build vector V2 from bone pivot to target
            #   Get the angle between V1 and V2
            #   Get the rotation direction
            #   Apply a differential rotation to the current bone
            #   If it is the base node then the new current bone is the last bone in the chain
            #   Else the new current bone is the previous one in the chain
            #End while
    effector = 'joint5'
    distance = (JOINTS[effector]['pos']).distance_to(targetTipPos)
    threshold = 0.5
    iterations = 10
    jointNum = 4
    while (distance > threshold and iterations > 0):
        while (jointNum > 3 and distance > threshold):
            #Current Joint & Position
            jointKey = 'joint'+str(jointNum)
            jointPos = JOINTS[jointKey]['pos']
            #Tip Position
            effectorPos = JOINTS[effector]['pos']

            #The Two Vectors of Interest
            V1 = (effectorPos - jointPos).normalized
            V2 = (targetTipPos - jointPos).normalized
            
            #Angle between the two vectors
            #theta = acos(Leap.Vector.dot(V1, V2))
            
            #Get the rotation axis
            #axis = Leap.Vector.cross(V1, V2)
            
            #Now get Euler angles from Maya
            rot = pm.angleBetween( euler=True, v1=V1.to_float_array(), v2=V2.to_float_array()) 
            
            #Now we rotate about these angles on the current Joint
            pm.xform(jointKey, ws=True, rotation=(rot[0], rot[1], rot[2]));
            
            #Update the coordinates of our tip position
            newCoords = pm.xform(effector, query=True, t=True, ws=True)
            #print "Old Tip Pos: "
            #print JOINTS[effector]['pos']
            JOINTS[effector]['pos'] = Leap.Vector(newCoords[0], newCoords[1], newCoords[2])
            #print "New Tip Pos: "
            #print JOINTS[effector]['pos']

            #Move onto next joint in the chain
            jointNum = jointNum - 1
            #Update distance
            #print "HERE!"
            distance = (JOINTS[effector]['pos']).distance_to(targetTipPos)
            
            updatePositionsFromIndex(jointNum)
            #initializePositions()
        #Decrement Iteration
        iterations = iterations - 1
            
def updatePositionsFromIndex(index):
    #Joint Positions
    while (index > 0):
        jointKey = 'joint'+str(index)
        #Get position of joint
        pos = pm.xform(jointKey, query=True, t=True, ws=True) #//in an array [x,y,z]
        JOINTS[jointKey]['base-pos'] = Leap.Vector(pos[0], pos[1], pos[2])
        JOINTS[jointKey]['pos'] = Leap.Vector(pos[0], pos[1], pos[2])

        #Get Rotatation of joint
        rot = pm.xform(jointKey, query=True, rotation=True)   
        JOINTS[jointKey]['rot'] = Leap.Vector(rot[0], rot[1], rot[2])
        index -= 1


perform_ccd() 
