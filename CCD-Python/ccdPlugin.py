#-
# ==========================================================================
# Copyright (C) 1995 - 2006 Autodesk, Inc. and/or its licensors.  All 
# rights reserved.
#
# The coded instructions, statements, computer programs, and/or related 
# material (collectively the "Data") in these files contain unpublished 
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its 
# licensors, which is protected by U.S. and Canadian federal copyright 
# law and by international treaties.
#
# The Data is provided for use exclusively by You. You have the right 
# to use, modify, and incorporate this Data into other products for 
# purposes authorized by the Autodesk software license agreement, 
# without fee.
#
# The copyright notices in the Software and this entire statement, 
# including the above license grant, this restriction and the 
# following disclaimer, must be included in all copies of the 
# Software, in whole or in part, and all derivative works of 
# the Software, unless such copies or derivative works are solely 
# in the form of machine-executable object code generated by a 
# source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
# AUTODESK DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED 
# WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF 
# NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
# PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
# TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS LICENSORS 
# BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK 
# AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
# OR PROBABILITY OF SUCH DAMAGES.
#
# ==========================================================================
#+

# import maya.cmds as cmds
# cmds.createNode("transform", name="ccdNode1")
# cmds.createNode("mesh", name="ccdNodeShape1", parent="ccdNode1")
# cmds.sets("ccdNodeShape1", add="initialShadingGroup")
# cmds.createNode("spccdNode", name="ccdNodeNode1")
# cmds.connectAttr("time1.outTime", "ccdNodeNode1.time")
# cmds.connectAttr("ccdNodeNode1.outputMesh", "ccdNodeShape1.inMesh")



cmds.createNode("transform", name="joint4")
cmds.connectAttr("time1.outTime", "joint4.time")
# cmds.createNode("spccdNode", name="ccdNodeNode1")
# cmds.connectAttr("time1.outTime", "ccdNodeNode1.time")
# cmds.connectAttr("ccdNodeNode1.outputMesh", "ccdNodeShape1.inMesh")


''' GET POSITION OF JOINT ''' # =====> cmds.getAttr('joint4.translate')
#To get position of joint in WS-> pos = cmds.getAttr(<objectName>.translate)
#return value is an array of size 1 containing an array of float values
# x-coord = pos[0][0]
# y-coord = pos[0][1]
# z-coord = pos[0][1]

''' SET POSITION OF JOINT ''' # =====> cmds.setAttr('joint4.translate',)
# setAttr object.translateY 10.5;
# or:
# setAttr object.translate -1.5 10.5 0;


'''PYMEL Example for translating in ws and get getting the current
        import pymel.all as pm
    #Translate using location coordinates
        pm.setAttr('joint4.translate', -1.5, 10.5, 0)

    #Translate in WS coordinates
        pm.xform('joint4', ws=True,t=(0, 0,0))
        f = pm.getAttr('joint4.translate')
        print f
        print pm.select('joint4')

    #Get World coordinates of object
    coords = pm.xform('joint4', t=True, query=True, ws=True) //in an array [x,y,z

    #Get Rotation of object
    coords = pm.xform('joint5', query=True, rotation=True)

'''


#SAMPLE_POINT = [13.327005785798825, 5.933350084777719, 1.6255290651771213];


import pymel.all as pm
import sys
import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
import Leap, string, math

kPluginNodeName = "spCCDNode"
kPluginNodeId = OpenMaya.MTypeId(0x8700B)

class ccdNode(OpenMayaMPx.MPxNode):
    time = OpenMaya.MObject()
    outputMesh = OpenMaya.MObject()

    def __init__(self):
        OpenMayaMPx.MPxNode.__init__(self)

    def createMesh(self, tempTime, outData):
        frame = int(tempTime.asUnits(OpenMaya.MTime.kFilm))
        if frame is 0:
            frame = 1
        # vtx_1 = OpenMaya.MFloatPoint(-cubeSize, -cubeSize, -cubeSize)
        # vtx_2 = OpenMaya.MFloatPoint( cubeSize, -cubeSize, -cubeSize)

        # points = OpenMaya.MFloatPointArray()
        # points.setLength(8)
        # faceCounts = OpenMaya.MIntArray()
        # meshFS = OpenMaya.MFnMesh()
        # newMesh = meshFS.create(numVertices, numFaces, points, faceCounts, faceConnects, outData)
        return 0
        # return newMesh

    def compute(self, plug, data):
        if plug == ccdNode.outputMesh:
            timeData = data.inputValue(ccdNode.time)
            tempTime = timeData.asTime()

            #outputHandle = data.outputValue(ccdNode.outputMesh)

            #dataCreator = OpenMaya.MFnMeshData()
            #newOutputData = dataCreator.create()

            self.createMesh(tempTime, newOutputData)

           # outputHandle.setMObject(newOutputData)
            data.setClean(plug)
        else:
            return OpenMaya.kUnknownParameter

def nodeCreator():
    return OpenMayaMPx.asMPxPtr( ccdNode() )

def nodeInitializer():
    unitAttr = OpenMaya.MFnUnitAttribute()
    typedAttr = OpenMaya.MFnTypedAttribute()

    ccdNode.time = unitAttr.create("time", "tm", OpenMaya.MFnUnitAttribute.kTime, 0.0)
    #ccdNode.outputMesh = typedAttr.create("outputMesh", "out", OpenMaya.MFnData.kMesh)

    ccdNode.addAttribute(ccdNode.time)
    #ccdNode.addAttribute(ccdNode.outputMesh)

    ccdNode.attributeAffects(ccdNode.time, ccdNode.outputMesh)

    #initialize positions of points
    initializePositions()


# initialize the script plug-in
def initializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.registerNode( kPluginNodeName, kPluginNodeId, nodeCreator, nodeInitializer)
    except:
        sys.stderr.write( "Failed to register node: %s" % kPluginNodeName )
        raise

# uninitialize the script plug-in
def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterNode( kPluginNodeId )
    except:
        sys.stderr.write( "Failed to deregister node: %s" % kPluginNodeName )
        raise
        
###################

import pymel.all as pm
import sys
import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
import Leap, string, math

#Target point of interest
TP = [13.327005785798825, 5.933350084777719, 1.6255290651771213];
TARGET_POINT = Leap.Vector(TP[0],TP[1], TP[2])

#Joints and Positions of finger
JOINTS = {
    'joint4': {
        'base-pos': Leap.Vector(0, 0, -15),
        'pos': Leap.Vector(0, 0, -15),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'tip-joint'
    },
    'joint5': {
        'base-pos': Leap.Vector(0, 0, -20),
        'pos': Leap.Vector(0, 0, -20),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'end-effector'
    }
   # 'joint1': {
    #     'base-pos': Leap.Vector(0, 0, 0),
    #     'pos': Leap.Vector(0, 0, 0),
    #     'rot': Leap.Vector(0, 90, 0),
    #     'name': 'palm'
    # },
    # 'joint2': {
    #     'base-pos': Leap.Vector(0, 0, -5),
    #     'pos': Leap.Vector(0, 0, -5),
    #     'rot': Leap.Vector(0, 0, 0),
    #     'name': 'knuckle'
    # },
    # 'joint3': {
    #     'base-pos': Leap.Vector(0, 0, -10),
    #     'pos': Leap.Vector(0, 0, -10),
    #     'rot': Leap.Vector(0, 0, 0),
    #     'name': 'mid-joint'
    # }, 
}



#Initialize our positions from out Maya joint        
def initializePositions():
    for key in JOINTS:
        print key
        #Get position of joint
        pos = pm.xform(key, query=True, t=True, ws=True) #//in an array [x,y,z]
        JOINTS[key]['base-pos'] = Leap.Vector(pos[0], pos[1], pos[2])
        JOINTS[key]['pos'] = Leap.Vector(pos[0], pos[1], pos[2])

        #Get Rotate of joint
        rot = pm.xform(key, query=True, rotation=True)   
        JOINTS[key]['rot'] = Leap.Vector(rot[0], rot[1], rot[2])


#CCD algorithm - with a targetPos
def perform_ccd(self, targetTipPos):
    print "ccd test"
    effector = 'joint5'
    effectorPos = JOINTS[effector]['pos']
    error = effectorPos.distance_to(targetTipPos)
    iterations = 10
    while (error > 0.5 and iterations > 0):
        i = 4
        while (i > 3):
            #Loop through each joint and update the joint positions
            #Pe - position of the end effector 
            pEnd = JOINTS[effector]['pos']

            #Pc - distance between the joint position and end effector position
            jointKey = 'joint'+str(i)
            print 'jointKey: ' + jointKey
            pBase = JOINTS[jointKey]['pos']

            #pT - target position
            pT = targetTipPos

            #peToPc
            pE_pC = (pEnd-pBase).normalized
            pT_pC = (pT-pBase).normalized
            #Angle of rotation
            try:  
                theta = math.acos(Leap.Vector.dot(pE_pC, pT_pC))
            except ValueError, e:
                print "Value error"
                break

            #Axis of Rotation
            rAxis = Leap.Vector.cross(pE_pC, pT_pC)
            #Get Rotation Matrix from Axis & Angle
            rotMat = Leap.Matrix(rAxis, theta)
            rMat = rotMat.to_array_3x3()

            phi = math.atan2(rMat[6], rMat[7]) * Leap.RAD_TO_DEG
            theta = math.acos(rMat[8]) * Leap.RAD_TO_DEG
            psi = -1*math.atan2(rMat[2], rMat[5]) * Leap.RAD_TO_DEG

            print str(phi) + " " + str(theta) + " " + str(psi) 
            #Update pBase by rotating it
            #pBase = rotMat.transform_point(pBase)
            #JOINTS[jointKey]['pos'] = pBase
            #Update the position of our end effector
            #JOINTS[effector]['pos'] = rotMat.transform_point(pEnd)
            
            #Rotate the connecting joint
            pm.xform(jointKey, ws=True, rotation=(phi, theta, psi));
            #get the new coordinates of the effector tip position
            newCoords = pm.xform(effector, query=True, t=True, ws=True)
            print "Old Tip Pos: "
            print JOINTS[effector]['pos']
            JOINTS[effector]['pos'] = Leap.Vector(newCoords[0], newCoords[1], newCoords[2])
            print "New Tip Pos: "
            print JOINTS[effector]['pos']


            # #Update rotation for with the current rot current
            # for j in range(i, 4):
            #     rotKey = 'joint' + str(j)
            #     JOINTS[jointKey]['pos'] =  rotMat.transform_point(JOINTS[jointKey]['pos'])


           # maya.rotate(jointKey, phi, theta, psi)
            
            #Move to next Joint
            i -= 1
        #Check error
        effectorPos = JOINTS[effector]['pos']
        error = effectorPos.distance_to(targetTipPos)
        iterations -= 1
    #Turn back on frame updates
    #Update pos for each joint in maya
    # for i in range(2, 5):
    #     jointKey = 'joint' + str(i)
    #     pos = JOINTS[jointKey]['pos']
    #     maya.move(jointKey, pos.x, pos.y, pos.z)
    # self.is_peforming_ccd = False
    #time.sleep(1) 
initializePositions()
perform_ccd(TARGET_POINT) 


''''
#PASTED IN MAYA
import pymel.all as pm
import sys
import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx
import Leap, string, math

#Target point of interest
TP = [13.327005785798825, 5.933350084777719, 1.6255290651771213];
TARGET_POINT = Leap.Vector(TP[0],TP[1], TP[2])

#Joints and Positions of finger
JOINTS = {
    'joint4': {
        'base-pos': Leap.Vector(0, 0, -15),
        'pos': Leap.Vector(0, 0, -15),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'tip-joint'
    },
    'joint5': {
        'base-pos': Leap.Vector(0, 0, -20),
        'pos': Leap.Vector(0, 0, -20),
        'rot': Leap.Vector(0, 0, 0),
        'name': 'end-effector'
    }
   # 'joint1': {
    #     'base-pos': Leap.Vector(0, 0, 0),
    #     'pos': Leap.Vector(0, 0, 0),
    #     'rot': Leap.Vector(0, 90, 0),
    #     'name': 'palm'
    # },
    # 'joint2': {
    #     'base-pos': Leap.Vector(0, 0, -5),
    #     'pos': Leap.Vector(0, 0, -5),
    #     'rot': Leap.Vector(0, 0, 0),
    #     'name': 'knuckle'
    # },
    # 'joint3': {
    #     'base-pos': Leap.Vector(0, 0, -10),
    #     'pos': Leap.Vector(0, 0, -10),
    #     'rot': Leap.Vector(0, 0, 0),
    #     'name': 'mid-joint'
    # }, 
}



#Initialize our positions from out Maya joint        
def initializePositions():
    for key in JOINTS:
        print key
        #Get position of joint
        pos = pm.xform(key, query=True, t=True, ws=True) #//in an array [x,y,z]
        JOINTS[key]['base-pos'] = Leap.Vector(pos[0], pos[1], pos[2])
        JOINTS[key]['pos'] = Leap.Vector(pos[0], pos[1], pos[2])

        #Get Rotate of joint
        rot = pm.xform(key, query=True, rotation=True)   
        JOINTS[key]['rot'] = Leap.Vector(rot[0], rot[1], rot[2])


#CCD algorithm - with a targetPos
def perform_ccd(self, targetTipPos):
    print "ccd test"
    effector = 'joint5'
    effectorPos = JOINTS[effector]['pos']
    error = effectorPos.distance_to(targetTipPos)
    iterations = 10
    while (error > 0.5 and iterations > 0):
        i = 4
        while (i > 3):
            #Loop through each joint and update the joint positions
            #Pe - position of the end effector 
            pEnd = JOINTS[effector]['pos']

            #Pc - distance between the joint position and end effector position
            jointKey = 'joint'+str(i)
            print 'jointKey: ' + jointKey
            pBase = JOINTS[jointKey]['pos']

            #pT - target position
            pT = targetTipPos

            #peToPc
            pE_pC = (pEnd-pBase).normalized
            pT_pC = (pT-pBase).normalized
            #Angle of rotation
            try:  
                theta = math.acos(Leap.Vector.dot(pE_pC, pT_pC))
            except ValueError, e:
                print "Value error"
                break

            #Axis of Rotation
            rAxis = Leap.Vector.cross(pE_pC, pT_pC)
            #Get Rotation Matrix from Axis & Angle
            rotMat = Leap.Matrix(rAxis, theta)
            rMat = rotMat.to_array_3x3()

            phi = math.atan2(rMat[6], rMat[7]) * Leap.RAD_TO_DEG
            theta = math.acos(rMat[8]) * Leap.RAD_TO_DEG
            psi = -1*math.atan2(rMat[2], rMat[5]) * Leap.RAD_TO_DEG

            print str(phi) + " " + str(theta) + " " + str(psi) 
            #Update pBase by rotating it
            #pBase = rotMat.transform_point(pBase)
            #JOINTS[jointKey]['pos'] = pBase
            #Update the position of our end effector
            #JOINTS[effector]['pos'] = rotMat.transform_point(pEnd)
            
            #Rotate the connecting joint
            pm.xform(jointKey, ws=True, rotation=(phi, theta, psi));
            #get the new coordinates of the effector tip position
            newCoords = pm.xform(effector, query=True, t=True, ws=True)
            print "Old Tip Pos: "
            print JOINTS[effector]['pos']
            JOINTS[effector]['pos'] = Leap.Vector(newCoords[0], newCoords[1], newCoords[2])
            print "New Tip Pos: "
            print JOINTS[effector]['pos']


            # #Update rotation for with the current rot current
            # for j in range(i, 4):
            #     rotKey = 'joint' + str(j)
            #     JOINTS[jointKey]['pos'] =  rotMat.transform_point(JOINTS[jointKey]['pos'])


           # maya.rotate(jointKey, phi, theta, psi)
            
            #Move to next Joint
            i -= 1
        #Check error
        effectorPos = JOINTS[effector]['pos']
        error = effectorPos.distance_to(targetTipPos)
        iterations -= 1
    #Turn back on frame updates
    #Update pos for each joint in maya
    # for i in range(2, 5):
    #     jointKey = 'joint' + str(i)
    #     pos = JOINTS[jointKey]['pos']
    #     maya.move(jointKey, pos.x, pos.y, pos.z)
    # self.is_peforming_ccd = False
    #time.sleep(1) 
initializePositions()
perform_ccd(TARGET_POINT) 
''''





